
/**
 * This template file was generated by dynaTrace client.
 * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
 * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
 **/

package com.Dynatrace;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.util.Collection;
import java.util.logging.Logger;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import com.dynatrace.diagnostics.pdk.ActionEnvironment;
import com.dynatrace.diagnostics.pdk.ActionV2;
import com.dynatrace.diagnostics.pdk.Incident;
import com.dynatrace.diagnostics.pdk.Status;
import com.dynatrace.diagnostics.pdk.Violation;

public class SlackChat implements ActionV2 {

	private static final Logger log = Logger.getLogger(SlackChat.class.getName());
	private Config confs = new Config();
	private Connection con = new Connection();

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this scheduled
	 * Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * 
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link #teardown(ActionEnvironment)} will be called
	 * next.
	 * 
	 * <p>
	 * Resources like sockets or files can be opened in this method. Resources
	 * like sockets or files can be opened in this method.
	 * 
	 * @param env
	 *            the configured <tt>ActionEnvironment</tt> for this Plugin
	 * @see #teardown(ActionEnvironment)
	 * @return a <tt>Status</tt> object that describes the result of the method
	 *         call
	 */
	@Override
	public Status setup(ActionEnvironment env) throws Exception {

		confs.setWebHookUrl(env.getConfigUrl("url"));
		confs.setChannel(env.getConfigString("channel"));
		confs.setNotifyAllChannel(env.getConfigBoolean("notifyAll"));
		confs.setLinkedDashboard(env.getConfigString("linkedDashboard"));
		
		con.setConnection(confs.getChannel(), confs.getWebHookUrl());

		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Action Plugin to process incidents.
	 * 
	 * <p>
	 * This method may be called at the scheduled intervals, but only if
	 * incidents occurred in the meantime. If the Plugin execution takes longer
	 * than the schedule interval, subsequent calls to
	 * {@link #execute(ActionEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link ActionEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link ActionEnvironment#isStopped()} or fails to stop execution
	 * in a reasonable timeframe, the execution thread will be stopped
	 * ungracefully which might lead to resource leaks!
	 * 
	 * @param env
	 *            a <tt>ActionEnvironment</tt> object that contains the Plugin
	 *            configuration and incidents
	 * @return a <tt>Status</tt> object that describes the result of the method
	 *         call
	 */
	@Override
	public Status execute(ActionEnvironment env) throws Exception {
		/*
		 * // this sample shows how to receive and act on incidents
		 * Collection<Incident> incidents = env.getIncidents(); for (Incident
		 * incident : incidents) { String message = incident.getMessage();
		 * log.info("Incident " + message + " triggered."); for (Violation
		 * violation : incident.getViolations()) { log.info("Measure " +
		 * violation.getViolatedMeasure().getName() + " violoated threshold.");
		 * } }
		 */

		// MAP ALL INCIDENTS A COLLECTION
		Collection<Incident> incidents = env.getIncidents();

		// FOR EACH INCIDENT
		for (Incident incident : incidents) {

			// LOG INCIDENT MESSAGE
			String message = incident.getMessage();
			log.fine("Incident " + message + " triggered.");

			// SET INPUT FIELDS
			URL url = confs.getWebHookUrl();
			String dashboard = confs.getLinkedDashboard();

			// JSON CREATION
			JSONObject jsonObj = new JSONObject();
			String state = "";
			// Compose string chat_message => This message will be sent to the
			// SlackChat channel
			if (confs.isNotifyAllChannel()) {
				state = "<!channel> ";
			}
			if (incident.isOpen()) {
				state = state + "dynatrace incident triggered:";
			} else if (incident.isClosed()) {
				state = state + "dynatrace incident ended:";
			}
			String title = incident.getIncidentRule().getName();
			String chat_message = "";
			// chat_message = chat_message + " <ul>";
			// chat_message = chat_message + "Incident UUID: " +
			// incident.getKey().getUUID() + "\n";

			chat_message = chat_message + "Incident start: " + incident.getStartTime() + "\n";
			chat_message = chat_message + "Incident end: " + incident.getEndTime() + "\n";

			// chat_message = chat_message + "<li><strong>Status state
			// code:</strong> " + incident.getState() + "</li>";

			chat_message = chat_message + "Message: " + message + "\n";

			for (Violation violation : incident.getViolations()) {
				chat_message = chat_message + "Violated Measure: " + violation.getViolatedMeasure().getName()
						+ " - Threshold: " + violation.getViolatedThreshold().getValue() + "\n";
			}
			
			try {
				con.sendMessage(con, confs, title, state, chat_message, incident.getSeverity().toString());
			}
			catch (Exception e) {
				log.severe("ERROR");
				log.severe(e.toString());
				return new Status(Status.StatusCode.ErrorInternal);
			}

			// chat_message = chat_message + "</ul>";

//			
//			if (!(dashboard == null || dashboard.equals("") || dashboard.isEmpty())) {
//				attachment.put("title_link", "http://" + incident.getServerName() + "/rest/management/reports/create/"
//						+ URLEncoder.encode(dashboard, "UTF-8").replaceAll("\\+", "%20"));
//			}
			

			// //TRY TO GET INPUT STREAM
			// try{
			// if(responseCode == 200){
			// in = con.getInputStream();
			// }
			// else{
			// in = con.getErrorStream();
			// }
			//
			// BufferedReader bufferReader = new BufferedReader(new
			// InputStreamReader(in));
			// responseBody = bufferReader.readLine();
			// bufferReader.close();
			// if(responseCode != 200){
			// log.warning("Response code was: " + responseCode);
			// log.warning("Error received from PagerDuty: " + responseBody);
			// }
			// }
			//
			// //CATCH EXCEPTION, LOG IT THEN SEND RESPONSE ERROR CODE
			// catch (IOException e) {
			// log.severe("Exception thrown whilst reading from input
			// stream...");
			// log.severe(e.toString());
			// return new Status (Status.StatusCode.ErrorInternalException);
			// }
		}

		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule
	 * timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and <tt>teardown</tt>
	 * are called on different threads, but they are called sequentially. This
	 * means that the execution of these methods does not overlap, they are
	 * executed one after the other.
	 * 
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt> ends
	 * -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout, <tt>execute</tt>
	 * stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is removed
	 * -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 * 
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 * 
	 * @see #setup(ActionEnvironment)
	 */
	@Override
	public void teardown(ActionEnvironment env) throws Exception {
		con.disconnect();
	}
}
